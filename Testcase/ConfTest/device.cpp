/***************************************************************************
//
// DEVICE.CPP
//
// TAPI Service provider for TSP++ version 3.00
// Handles raw device events and the physical connection to the hardware.
//
// Copyright (C) 1999 JulMar Technology, Inc.
// All rights reserved
//
// Generated by the TSPWizard (C) JulMar Technology, Inc.
// 
/***************************************************************************/

/*----------------------------------------------------------------------------
	INCLUDE FILES
-----------------------------------------------------------------------------*/
#include "stdafx.h"
#include <process.h>
#include "ConfTest.h"

/*****************************************************************************
** Procedure:  MainConnThread
**
** Arguments:  'pDevice'	- Device object
**
** Returns:    void
**
** Description:  Main connection thread
**
*****************************************************************************/
static unsigned __stdcall MainConnThread(void* pParam)
{
	reinterpret_cast<CConfTestDevice*>(pParam)->ConnectionThread();
	_endthreadex(0);
	return 0;

}// ConnThread

/*****************************************************************************
** Procedure:  CConfTestDevice::CConfTestDevice
**
** Arguments:  void
**
** Returns:    void
**
** Description: Constructor for the device object
**
*****************************************************************************/
CConfTestDevice::CConfTestDevice() : m_hConnThread(0)
{
	// Create the stop event.
	m_hevtStop = CreateEvent (NULL, true, false, NULL);
	InitializeCriticalSection(&m_csData);

	// TODO: place any constructor code here

}// CConfTestDevice::CConfTestDevice

/*****************************************************************************
** Procedure:  CConfTestDevice::~CConfTestDevice
**
** Arguments:  void
**
** Returns:    void
**
** Description:  Destructor for the device object
**
*****************************************************************************/
CConfTestDevice::~CConfTestDevice()
{
	// Stop the input thread and wait for it to terminate.
	SetEvent (m_hevtStop);
	WaitForSingleObject(m_hConnThread, 5000);
	CloseHandle(m_hConnThread);

	// Close all our synchronization object handles
	CloseHandle(m_hevtStop);
	DeleteCriticalSection(&m_csData);

	// TODO: destroy any allocated memory here

}// CConfTestDevice::~CConfTestDevice

/*****************************************************************************
** Procedure:  CConfTestDevice::Init
**
** Arguments:  'dwProviderId'		-	TAPI provider ID
**             'dwBaseLine'			-	Starting line index from TAPI system
**             'dwBasePhone'		-	Starting phone index from TAPI system
**             'dwLines'			-	Number of lines owned by this device
**             'dwPhones'			-	Number of phones owned by this device
**             'hProvider'			-	Opaque Provider handle from TAPI
**			   'lpfnCompletion'		-	Completion PROC for any ASYNCH requests.
**
** Returns:    true/false whether TAPI should continue loading the device.
**
** Description: This function is called during providerInit to initialize
**              each device identified by TAPI (group of lines/phones).
**              It is overriden to create threads and other init-time work
**              that might fail (and therefore shouldn't be done in the 
**              constructor).
**
*****************************************************************************/
bool CConfTestDevice::Init(DWORD dwProviderId, DWORD dwBaseLine, DWORD dwBasePhone, 
					 DWORD dwLines, DWORD dwPhones, HPROVIDER hProvider, 
					 ASYNC_COMPLETION lpfnCompletion)
{
	// Add the switch information so others can identify this provider.
	SetSwitchInfo(_T("Internal No-Switch"));

	// Turn on the interval timer for this device for once every second
	SetIntervalTimer(1000);

	// Pass through to the base class and let it initialize the line and phone 
	// devices.  After this call, each of the objects will be available.
	// In addition, the providerID information will be filled in.
	if (CTSPIDevice::Init (dwProviderId, dwBaseLine, dwBasePhone, dwLines, dwPhones, hProvider, lpfnCompletion))
	{
		// Create our connection thread which manages the connection to the hardware.
		UINT uiThread;
		m_hConnThread = reinterpret_cast<HANDLE>(_beginthreadex(NULL, 0, MainConnThread, static_cast<void*>(this), 0, &uiThread));

		// If the thread failed to create, output an error and tell TAPI to stop
		// loading us (fatal initialization error).
		if (m_hConnThread == NULL)
		{
			_TSP_DTRACE(_T("Failed to create input thread\n"), GetLastError());
			return false;
		}

		// Tell TAPI to continue loading our provider.
		return true;
	}
	return false;

}// CConfTestDevice::Init

/*****************************************************************************
** Procedure:  CConfTestDevice::ConnectionThread
**
** Arguments:  void
**
** Returns:    Thread return code
**
** Description:  This thread manages the communication connection to the hardware.
**
*****************************************************************************/
unsigned CConfTestDevice::ConnectionThread()
{
	// Loop around trying to connect and then receiving data
	bool fConnected = false;
	while (WaitForSingleObject(m_hevtStop, 0) == WAIT_TIMEOUT)
	{
		// TODO: Remove this sleep command once the thread pauses waiting
		// for events from the hardware. This was iserted so that the generated
		// provider doesn't soak up CPU time when tested.
		Sleep(1000);

		// Keep trying to connect
		while (!fConnected)
		{
			// TODO: Connect to the hardware device
			fConnected = true;
		}

		// TODO: Receive a packet/event from the switch

		// TODO: Parse the packet into a CPBXEvent
		CPBXEvent* pEvent = NULL;

		// Determine the owner of the event
		CTSPIConnection* pConnOwner = LocateOwnerFromEvent(pEvent);

		// Add it to the pool manager
		bool fDispatched = (pConnOwner != NULL && 
				m_mgrThreads.Add(pConnOwner, pConnOwner->GetPermanentDeviceID(), pEvent));

		// Delete it if we could not find an owner. This could happen if the TSP
		// never saw required preceding events (such as call creations) because it 
		// wasn't running at the time or an event loss occurred due to link failure.
		if (!fDispatched)
			TPM_DelEvent(pEvent);
	}

	return 0;

}// CConfTestDevice::ConnectionThread

/*****************************************************************************
** Procedure:  CConfTestDevice::LocateOwnerFromEvent
**
** Arguments:  'pEvent' - Event received from the hardware
**
** Returns:    CTSPIConnection which "owns" the event.
**
** Description: This function examines the received event and determines
**              which connection object the event belongs to.
**
*****************************************************************************/
CTSPIConnection* CConfTestDevice::LocateOwnerFromEvent(CPBXEvent* pEvent)
{
	CTSPIConnection* pConnOwner = NULL;

	// TODO: Examine the event and determine which line or phone object it 
	// refers to.
	//
	// Many telephony systems send a "station identifier" or owner with
	// each event so that link monitoring software can properly track things.
	//
	// You can associate an identifier with lines and phones by calling the
	// CTSPILineConnection::SetPermanentLineID and CTSPIPhoneConnection::SetPermanentPhoneID
	// functions, then they can be found as follows:
	
	DWORD dwIdentifier = 0;

	bool fIsLineEvent = false;
	if (pConnOwner == NULL && fIsLineEvent)
	{
		pConnOwner = FindLineConnectionByPermanentID(dwIdentifier);
	}

	// Another item that comes with many events is the call-id. This uniquely
	// identifies the call on the hardware.

	DWORD dwCallID = 0;

	// If we received a call-id, check for in-switch calls (station-to-station)
	// and see if another call object is sharing this call-id. If this is the
	// case, determine which call the event refers to.
	if (pConnOwner == NULL && dwCallID != 0)
	{
		const CTSPICallHub* pHub = FindCallHub(dwCallID);
		if (pHub != NULL)
		{
			if (pHub->GetHubCount() > 1)
			{
				// TODO: Determine which call it refers to
			}
			else
			{
				CTSPICallAppearance* pCall = pHub->GetCall(0);
				pConnOwner = pCall->GetLineOwner();
			}
		}
	}

	return pConnOwner;
	
}// CConfTestDevice::LocateOwnerFromEvent
