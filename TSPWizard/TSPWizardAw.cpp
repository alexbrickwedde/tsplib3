// TSPWizardaw.cpp : implementation file
//

#include "stdafx.h"
#include "TSPWizard.h"
#include "TSPWizardaw.h"
#include "cstm0dlg.h"
#include "cstm1dlg.h"
#include "cstm2dlg.h"
#include "cstm2_3dlg.h"
#include "cstm3dlg.h"
#include "cstm4dlg.h"
#include "cstm5dlg.h"
#include "parser.h"
#include <direct.h>
#include <errno.h>
#include <io.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Here we define one instance of the CTSPWizardAppWiz class.  You can access
//  m_Dictionary and any other public members of this class through the
//  global TSPWizardaw.
CTSPWizardAppWiz TSPWizardaw;

// CTSPWizardDlg message handlers
BEGIN_MESSAGE_MAP(CTSPWizardAppWiz, CPropertySheet)
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
END_MESSAGE_MAP()

BEGIN_MESSAGE_MAP(CAppWizStepDlg, CPropertyPage)
	ON_WM_PAINT()
END_MESSAGE_MAP()

CTSPWizardAppWiz::CTSPWizardAppWiz(CWnd* pParentWnd) :
	CPropertySheet("", pParentWnd)
{
}

INT_PTR CTSPWizardAppWiz::DoModal()
{
	m_hIcon = AfxGetApp()->LoadIcon(IDI_TSPWIZARD);

	// Remove everything from our dictionary
	m_Dictionary.RemoveAll(); 

	// Add our default dictionary items
	COleDateTime dtNow = COleDateTime::GetCurrentTime();
	m_Dictionary["CURR_YEAR"] = dtNow.Format("%Y");
	CString strCopyright; strCopyright.Format("Generated by the TSPWizard © %s JulMar Technology, Inc.", m_Dictionary["CURR_YEAR"]);
	m_Dictionary["JULMAR_INFO"] = strCopyright;

	// Default values
	m_Dictionary["MAXONHOLD"] = "0";
	m_Dictionary["CONFMAXCOUNT"] = "0";
	m_Dictionary["CONFTRANSFMAXCOUNT"] = "0";
	m_Dictionary["TRANSF_MAXONHOLD"] = "0";
	m_Dictionary["DIALTONE_DEFAULT"] = "LINEDIALTONEMODE_NORMAL";

	// Add each property page
	AddPage(new CCustom0Dlg);	// 0 - Intro
	AddPage(new CCustom1Dlg);	// 1 - Company info
	AddPage(new CCustom2Dlg);	// 2 - Basic info
	AddPage(new CCustom2_3Dlg); // 3 - Device Info
	AddPage(new CCustom3Dlg);	// 4 - Call Control info
	AddPage(new CCustom4Dlg);	// 5 - Phone Info
	AddPage(new CCustom5Dlg);	// 6 - Final

	// Set the wizard mode
	SetWizardMode();

	AfxGetApp()->m_pMainWnd = this;

	// If the Property sheet is dismissed with an OK result, then
	// begin our parsing project..
	INT_PTR result = CPropertySheet::DoModal();
	if (result == ID_WIZFINISH)
	{
		// Remove any pending messages - ala WM_QUIT.
		MSG msg;
		while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
			;

		// Walk through our map and remove any "No" items from our map.
		for (POSITION pos = m_Dictionary.GetStartPosition(); pos != NULL; )
		{
			CString strKey, strValue;
			m_Dictionary.GetNextAssoc(pos, strKey, strValue);
			if (strValue == "No")
			{
				m_Dictionary.RemoveKey(strKey);
				pos = m_Dictionary.GetStartPosition();
			}
		}

		// Load up newproj.inf - this is the list of files to parse.
		if (GenerateFileList())
		{
			CString strProject; 
			strProject.Format("The TSPWizard has created your project in %s\\%s",
					m_Dictionary["PATH"], m_Dictionary["Safe_root"]);
			AfxMessageBox(strProject, MB_OK | MB_ICONASTERISK);
		}
	}
	
	return result;
}

BOOL CTSPWizardAppWiz::OnInitDialog()
{
	CPropertySheet::OnInitDialog();

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon

	CString strCaption; strCaption.LoadString(IDS_CAPTION);
	SetWindowText(strCaption);

	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CTSPWizardAppWiz::DoDataExchange(CDataExchange* pDX)
{
	CPropertySheet::DoDataExchange(pDX);
}

// This is called just before the custom AppWizard is unloaded.
CTSPWizardAppWiz::~CTSPWizardAppWiz()
{
	for (int i = 0; i < GetPageCount(); ++i)
		delete GetPage(i);
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CTSPWizardAppWiz::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CPropertySheet::OnPaint();
	}
}

// The system calls this function to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CTSPWizardAppWiz::OnQueryDragIcon()
{
	return static_cast<HCURSOR>(m_hIcon);
}

// This is called when the user clicks "Create..." on the New Project dialog
//  or "Next" on one of the custom AppWizard's steps.
int CTSPWizardAppWiz::Next()
{
	CString strValue;
	int nCurrDlg = GetPageIndex(GetActivePage());
	if (nCurrDlg == 3 &&
		(!m_Dictionary.Lookup("OVERRIDE_LINE", strValue) || strValue == "No"))
		nCurrDlg++;
	if (nCurrDlg == 4 &&
		(!m_Dictionary.Lookup("OVERRIDE_PHONE", strValue) || strValue == "No"))
		nCurrDlg++;

	// Move to the correct page.
	return IDD_CUSTOM0 + nCurrDlg + 1;
}

// This is called when the user clicks "Back" on one of the custom
//  AppWizard's steps.
int CTSPWizardAppWiz::Back()
{
	CString strValue;
	int nCurrDlg = GetPageIndex(GetActivePage());
	if (nCurrDlg == 6 &&
		(!m_Dictionary.Lookup("OVERRIDE_PHONE", strValue) || strValue == "No"))
		nCurrDlg--;
	if (nCurrDlg == 5 &&
		(!m_Dictionary.Lookup("OVERRIDE_LINE", strValue) || strValue == "No"))
		nCurrDlg--;

	// Move to the correct page.
	return IDD_CUSTOM0 + nCurrDlg - 1;
}

#if 0
// This is called immediately after the default Debug and Release
//  configurations have been created for each platform.  You may customize
//  existing configurations on this project by using the methods
//  of IBuildProject and IConfiguration such as AddToolSettings,
//  RemoveToolSettings, and AddCustomBuildStep. These are documented in
//  the Developer Studio object model documentation.
void CTSPWizardAppWiz::CustomizeProject(IBuildProject* pProject)
{
	// Tell the user about the UI project
	CString strValue;
	if (m_Dictionary.Lookup("HAS_UI", strValue) && strValue == "Yes")
		AfxMessageBox(IDS_HASUI);

	using namespace DSProjectSystem;
	long lNumConfigs;
	IConfigurationsPtr pConfigs;
	IBuildProjectPtr pProj;

	// Needed to convert IBuildProject to the DSProjectSystem namespace
	pProj.Attach((DSProjectSystem::IBuildProject*)pProject, true);

	pProj->get_Configurations(&pConfigs);
	pConfigs->get_Count(&lNumConfigs);

	// Go through each configuration and remove MFC dependancies.
	for (long j = 1; j < lNumConfigs+1; j++)
	{
		_bstr_t varTool;
		_bstr_t varSwitch;
		_bstr_t varName;
		IConfigurationPtr pConfig;
		_variant_t varj = j;

		pConfig = pConfigs->Item(varj);

		BSTR bstrName;
		pConfig->get_Name(&bstrName);
		varName = bstrName;
		bool fDebug = (bool) (strstr(varName, "Debug") != NULL);

		varTool   = "cl.exe";
		varSwitch = "/D \"_AFXDLL\"";
		pConfig->RemoveToolSettings(varTool, varSwitch, varj);
		varSwitch = "/D \"_USRDLL\"";
		pConfig->RemoveToolSettings(varTool, varSwitch, varj);
		varSwitch = "/D \"_MBCS\"";
		pConfig->RemoveToolSettings(varTool, varSwitch, varj);
		varSwitch = (fDebug) ? "/MDd" : "/MD";
		pConfig->RemoveToolSettings(varTool, varSwitch, varj);

		varTool   = "rc.exe";
		varSwitch = "/d \"_AFXDLL\"";
		pConfig->RemoveToolSettings(varTool, varSwitch, varj);

		varTool = "link.exe";
		varSwitch = "/out:";
		pConfig->RemoveToolSettings(varTool, varSwitch, varj);
		varSwitch = "/implib:";
		pConfig->RemoveToolSettings(varTool, varSwitch, varj);

		// Add Libs that MFC headers would have pulled in automatically
		// Feel free to customize this listing to your tastes
		varTool = "link.exe";
		varSwitch = "kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib";
		if (m_Dictionary.Lookup("USE_WINSOCK", strValue) && strValue == "Yes")
			varSwitch += " wsock32.lib";
		if (m_Dictionary.Lookup("ISTAPI3", strValue) && strValue == "Yes")
			varSwitch += " t3iid.lib";
		pConfig->AddToolSettings(varTool, varSwitch, varj);

		varTool = "cl.exe";
		if (m_Dictionary.Lookup("WINNTONLY", strValue) && strValue == "Yes")
		{
			// Make it a Unicode build
			varSwitch = "/D \"UNICODE\"";
			pConfig->AddToolSettings(varTool, varSwitch, varj);
			varSwitch = "/D \"_UNICODE\"";
			pConfig->AddToolSettings(varTool, varSwitch, varj);
		}

		varSwitch = (fDebug) ? "/MTd" : "/MT";
		pConfig->AddToolSettings(varTool, varSwitch, varj);
		varSwitch = "/D \"STRICT\"";
		pConfig->AddToolSettings(varTool, varSwitch, varj);

		// Add RTTI support
		varSwitch = "/GR";
		pConfig->AddToolSettings(varTool, varSwitch, varj);

		// Add TSPLIB include path
		varSwitch = "/I \"\\TSPLIB3\\INCLUDE\"";
		pConfig->AddToolSettings(varTool, varSwitch, varj);

		// Change output name to TSP
		varTool = "link.exe";
		varSwitch = fDebug ? "/out:Debug\\" : "/out:Release\\";
		varSwitch += m_Dictionary[_T("safe_root")].AllocSysString();
		varSwitch += ".tsp";
		pConfig->AddToolSettings(varTool, varSwitch, varj);

		// Add our libpath
		varSwitch = "/libpath:\"\\TSPLIB3\\LIB";
		pConfig->AddToolSettings(varTool, varSwitch, varj);

		SysFreeString(bstrName);
	}
}
#endif

CString CTSPWizardAppWiz::ReadFileFromResource(const char* pszName)
{
	CString strData;

	HMODULE hModule = AfxGetResourceHandle();
	HRSRC hResource = FindResource(hModule, pszName, "TEMPLATE");
	if (hResource != NULL)
	{
		DWORD size = SizeofResource(hModule, hResource);
		HGLOBAL hHandle = LoadResource(hModule, hResource);
		if (hHandle != NULL)
		{
			strData = CString((LPSTR)LockResource(hHandle), size);
		}
	}
	
	return strData;
}

bool CTSPWizardAppWiz::CreatePath(const char* pszPath)
{
	const char* pszCurr = pszPath;
	CString strPath;

	while (*pszCurr != '\0')
	{
		if (*pszCurr == '\\')
		{
			strPath = CString(pszPath, (int) (pszCurr-pszPath));
			if (strPath.Right(1) != ':')
			{
				if (_mkdir(strPath) == -1 && errno != EEXIST)
					return false;
			}
		}
		++pszCurr;
	}

	return (_mkdir(pszPath) != -1 || errno == EEXIST);
}

bool CTSPWizardAppWiz::GenerateFileList()
{
	// Build our path
	CString strPath = m_Dictionary["PATH"]; strPath.Trim();
	if (strPath.Right(1) != '\\')
		strPath += '\\';
	strPath += m_Dictionary["Safe_root"];
	if (!CreatePath(strPath))
	{
		AfxMessageBox(IDS_FAILED_CREATE_DIR);
		return false;
	}

	// Re-check for our project name.. just so we don't overwrite files.
	CString strDummy = strPath; strDummy += '\\'; 
	strDummy += m_Dictionary["Safe_root"];
	strDummy += ".cpp";
	if (_access(strDummy,0) != -1)
	{
		AfxMessageBox(IDS_PROJECTEXISTS);
		return false;
	}

	CParser parser(m_Dictionary, NULL);

	// Process our file list.
	CString strFileList = ReadFileFromResource("NEWPROJ.INF");
	parser.SetData(strFileList);
	CString strResource, strFile;
	while (parser.GetNext(strResource))
	{
		strResource.Trim(' ');
		if (!strResource.IsEmpty() && strResource[0] != '\n')
		{
			// Read to end of line - converting each token in place.
			strDummy.Empty();
			do
			{
				if (!strDummy.IsEmpty())
					strResource += strDummy;
				if (!parser.GetNext(strDummy))
					break;

			} while (strDummy != "\n");

			TRACE("Executing - %s\n", strResource);

			// If this is a create directory command, then do that.
			if (strResource.Left(1) == '/')
			{
				strResource = strPath + "\\" + strResource;
				if (!CreatePath(strResource))
				{
					AfxMessageBox(IDS_FAILED_CREATE_DIR);
					return false;
				}
				continue;
			}

			// Template is separated from filename by tab.
			int pos = strResource.Find('\t');
			if (pos == -1)
			{
				AfxMessageBox(IDS_BAD_CONFIG);
				return false;
			}
			else
			{
				strFile = strResource.Mid(pos+1);
				strResource = strResource.Left(pos);
			}

			CString strData = ReadFileFromResource(strResource);
			CParser fileParser(m_Dictionary, strData);
			CString strFileName = strPath + "\\" + strFile;
			if (strData.IsEmpty() || !ProcessFile(fileParser, strData, strFileName))
			{
				AfxMessageBox(IDS_FAILED_CREATEFILE);
				return false;
			}
		}
	}
	return true;
}

bool CTSPWizardAppWiz::ProcessFile(CParser& parser, const char* pszBuff, const char* pszFilename)
{
	// Prime the parser with data
	parser.SetData(pszBuff);

	// Open our output file.
	CStdioFile fileOut;
	if (!fileOut.Open(pszFilename, CFile::modeCreate | CFile::modeWrite | CFile::typeText, NULL))
		return false;

	// Read the data and write it to our file.
	CString strData;
	while (parser.GetNext(strData))
		fileOut.WriteString(strData);

	// Close the file.
	fileOut.Close();
	return true;
}

void CAppWizStepDlg::OnPaint()
{
	Default();

	HINSTANCE hInstance = AfxGetResourceHandle();
	UINT uiPicRes = IDB_LOGO1;

	// If we have a bitmap associated with this page, then paint it.
	if (hInstance && uiPicRes)
	{
		CClientDC dc(this);

		// Set the current resource.
		HINSTANCE hPrevInstance = AfxGetResourceHandle();
		if (hPrevInstance != hInstance)
			AfxSetResourceHandle(hInstance);

		// Load the bitmap.
		CBitmap bmpPic;
		if (bmpPic.LoadBitmap(uiPicRes))
		{
			// Create a memory DC to hold the bitmap temporarily.
			CDC memDC;
			if (memDC.CreateCompatibleDC(&dc))
			{
				// Get our bounding rect.
				CRect rcBox;
				GetDlgItem(IDC_PICTURE)->GetWindowRect(&rcBox);
				ScreenToClient(rcBox);

				// Get the bitmap dimensions
				BITMAP bmpDim;
				bmpPic.GetObject(sizeof(BITMAP), &bmpDim);

				// Stretch it over our area.
				CBitmap* pbmpOld = (CBitmap*) memDC.SelectObject(&bmpPic);
				dc.StretchBlt (rcBox.left, rcBox.top, rcBox.Width(), rcBox.Height(),
					&memDC, 0, 0, bmpDim.bmWidth, bmpDim.bmHeight, SRCCOPY);
				memDC.SelectObject(pbmpOld);
			}
		}

		// Reset the instance handle.
		if (hPrevInstance != hInstance)
			AfxSetResourceHandle(hPrevInstance);
	}

}// CAppWizStepDlg::OnPaint

